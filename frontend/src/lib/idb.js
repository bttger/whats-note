import * as idb from "idb";

export async function openDB() {
  return await idb.openDB("whats-note", 1, {
    upgrade(db) {
      /**
       * interface Event {
       *   id: string; // 12 characters, generated by nanoid
       *   itemId: string; // Either the message or note ID that the event relates to
       *   emittedAt: number;
       *   type: "editNote" | "postMsg" | "deleteMsg" | "checkMsg" | "uncheckMsg" | "editMsg";
       *   data: string; // JSON stringified event data, e.g. MessageData or NoteData
       * }
       */
      db.createObjectStore("unsyncedEvents", {
        keyPath: "id",
      });

      /**
       * interface Message {
       *   id: string; // 10 characters, generated by nanoid
       *   sentAt: number; // Unix milliseconds
       *   data: MessageData;
       * }
       *
       * interface MessageData {
       *   text: string;
       *   tag: Tag;
       *   checked: boolean;
       * }
       *
       * interface Tag {
       *   id: number;
       *   name: string;
       *   color: string;
       * }
       */
      const messages = db.createObjectStore("messages", {
        keyPath: "id",
      });
      messages.createIndex("sentAt", "sentAt");

      /**
       * interface Note {
       *   id: number;
       *   lastEdit: number; // Unix milliseconds
       *   data: NoteData;
       * }
       *
       * interface NoteData {
       *   text: string;
       * }
       */
      db.createObjectStore("notes", {
        keyPath: "id",
      });
    },
  });
}

export async function selectUnsyncedEvents(db) {
  return await db.getAll("unsyncedEvents");
}

export async function insertUnsyncedEvent(db, chatEvent) {
  await db.put("unsyncedEvents", chatEvent);
}

export async function deleteUnsyncedEvent(db, chatEventId) {
  await db.delete("unsyncedEvents", chatEventId);
}

export async function selectMessages(db, count) {
  const messages = [];

  const unsyncedEvents = await db.getAll("unsyncedEvents");

  let cursor = await db
    .transaction("messages", "readonly")
    .store.index("sentAt")
    .openCursor(null, "prev");

  while (cursor && count > messages.length) {
    // TODO check if it is more performant to use an index on "itemId" and making an idb request for each message
    if (unsyncedEvents.some((e) => e.itemId === cursor.value.id)) {
      cursor.value.unsynced = true;
    }
    messages.unshift(cursor.value);
    cursor = await cursor.continue();
  }

  return messages;
}

async function updateMessage(db, id, partialMessageDataObj) {
  let message = await db.get("messages", id);
  message.data = { ...message.data, ...partialMessageDataObj };
  await db.put("messages", message);
}

export async function applyEvents(db, chatEvents) {
  for (const e of chatEvents) {
    const data = e.data ? JSON.parse(e.data) : null;
    switch (e.type) {
      case "editNote":
        db.put("notes", {
          id: parseInt(e.itemId),
          lastEdit: e.emittedAt,
          data: { text: data.text },
        });
        break;
      case "postMsg":
        await db.put("messages", {
          id: e.itemId,
          sentAt: e.emittedAt,
          data: {
            text: data.text,
            tag: data.tag,
            checked: false,
          },
        });
        break;
      case "editMsg":
        await updateMessage(db, e.itemId, data);
        break;
      case "checkMsg":
        await updateMessage(db, e.itemId, { checked: true });
        break;
      case "uncheckMsg":
        await updateMessage(db, e.itemId, { checked: false });
        break;
      case "deleteMsg":
        await db.delete("messages", e.itemId);
        break;
    }
  }
}

export async function selectNote(db, id) {
  return (
    (await db.get("notes", id)) || {
      id,
      data: { text: "" },
      lastEdit: Date.now(),
    }
  );
}

export async function selectNotes(db) {
  return await db.getAll("notes");
}

export async function startUpdateNote(db, id, text) {
  const note = await selectNote(db, id);
  note.text = text;
  note.lastEdit = Date.now();
  note.isSyncing = 1;
  note.unsynced = 1;
  await db.put("notes", note);
  return note;
}

export async function finishUpdateNote(db, id, error = false) {
  const note = await selectNote(db, id);
  note.isSyncing = 0;
  note.unsynced = error ? 1 : 0;
  note.lastSync = error ? note.lastSync : Date.now();
  await db.put("notes", note);
  return note;
}
