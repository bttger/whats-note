<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Note Messenger</title>
    <meta
      name="description"
      content="Send yourself messages, organize your notes, and sync them with all your devices"
    />
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" type="image/png" href="/images/NotoV1Memo_64x64.png" />
    <link rel="stylesheet" href="/css/style.css" />
    <script
      defer
      src="https://unpkg.com/alpinejs@3.10.3/dist/cdn.min.js"
    ></script>
    <script>
      function scrollIntoView(id, smooth = false) {
        const elem = document.getElementById(id);
        elem.scrollIntoView({ behavior: smooth ? "smooth" : "auto" });
      }

      function pasteAsPlainText(event) {
        event.preventDefault();
        document.execCommand(
          "insertHTML",
          false,
          event.clipboardData.getData("text/plain")
        );
      }

      function data() {
        return {
          init() {
            this.openTab(0);
          },
          // 0: Synced, 1: Syncing, 2: Unsynced due to network error
          state: 1,
          open: 0,
          tabs: [0, 1, 2, 3, 4, 5],
          messages: [],
          unsyncedMessages: [],
          notes: {},
          messagesPage: 0,
          async openTab(id) {
            this.open = id;
            this.state = 1;
            if (this.open === 0) {
              this.loadMessagesFromStore();
              await this.getMessages();
            } else {
              await this.getNote(this.open);
            }
            if (this.state === 1) {
              this.state = 0;
            }
          },
          scrollLastMsgIntoView() {
            const lastId = this.messages[this.messages.length - 1]?.id;
            if (lastId) {
              this.$nextTick(() => scrollIntoView(lastId));
            }
          },
          loadMessagesFromStore() {
            this.messages =
              JSON.parse(window.localStorage.getItem("messages")) || [];
            this.unsyncedMessages =
              JSON.parse(window.localStorage.getItem("unsyncedMessages")) || [];
            this.scrollLastMsgIntoView();
          },
          syncMessagesWithStore() {
            window.localStorage.setItem(
              "messages",
              JSON.stringify(this.messages)
            );
            window.localStorage.setItem(
              "unsyncedMessages",
              JSON.stringify(this.unsyncedMessages)
            );
          },
          async getMessages() {
            try {
              const response = await fetch("/api/messages", { method: "GET" });
              if (response.ok) {
                this.messages = await response.json();
                this.scrollLastMsgIntoView();
                this.syncMessagesWithStore();
              } else if (response.status === 401) {
                window.location.replace("/login");
              } else {
                this.state = 2;
              }
            } catch (error) {
              this.state = 2;
            }
          },
          async postMessage(message) {
            if (!message) return;

            const id = crypto.randomUUID();
            const body = {
              id,
              text: message,
              sentAt: Date.now(),
              checked: false,
            };
            this.unsyncedMessages.push({ inProgress: true, body });
            this.messages.push(body);
            this.$nextTick(() => scrollIntoView(id, true));

            this.syncMessagesWithStore();

            try {
              const response = await fetch("/api/messages", {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                },
                body: JSON.stringify(body),
              });
              if (response.ok) {
                // Remove from unsynced queue
                this.unsyncedMessages = this.unsyncedMessages.filter(
                  (m) => m.body.id !== body.id
                );
              } else if (response.status === 401) {
                window.location.replace("/login");
              } else {
                // Update inProgress prop in unsynced queue
                const found = this.unsyncedMessages.find(
                  (m) => m.body.id === body.id
                );
                found.inProgress = false;
                this.state = 2;
              }
            } catch (error) {
              // Update inProgress prop in unsynced queue
              const found = this.unsyncedMessages.find(
                (m) => m.body.id === body.id
              );
              found.inProgress = false;
              this.state = 2;
            }

            this.syncMessagesWithStore();
          },
          async checkOffMessage(id, index, checkOff = true) {
            function resetCheckbox() {
              document.getElementById(`checkbox-${id}`).checked = !checkOff;
            }

            try {
              const response = await fetch(`/api/messages/${id}`, {
                method: "PATCH",
                headers: {
                  "Content-Type": "application/json",
                },
                body: JSON.stringify({ checked: checkOff }),
              });
              if (response.ok) {
                this.messages[index].checked = checkOff;
              } else if (response.status === 401) {
                window.location.replace("/login");
              } else {
                resetCheckbox();
              }
            } catch (error) {
              resetCheckbox();
            }
          },
          renderMessageInfoText(message) {
            const date = new Date(message.sentAt).toLocaleString();
            const found = this.unsyncedMessages.find(
              (m) => m.body.id === message.id
            );
            if (!found) {
              return date + " âœ“";
            }
            if (found.inProgress) {
              return date + " o";
            }
            return date + " x";
          },
          async getNote(id) {
            // TODO
          },
          async putNote(id) {
            // TODO
          },
        };
      }
    </script>
  </head>
  <body x-data="data()">
    <div class="container">
      <!-- ------ STATE BAR ------ -->
      <div
        x-show="state !== 0"
        class="state-bar"
        :style="state === 1 ? 'background: #000bda' : 'background: #d80000'"
      ></div>
      <!-- ------ TAB NAVIGATION ------ -->
      <div class="tabs">
        <template x-for="tab in tabs">
          <div
            x-text="tab"
            class="button tab"
            :class="tab === open && 'focused'"
            @click="openTab(tab)"
          ></div>
        </template>
      </div>
      <!-- ------ MESSENGER ------ -->
      <template x-if="open === 0">
        <div class="filler-container">
          <template x-for="(message, index) in messages" :key="message.id">
            <div class="message-container">
              <input
                :id="'checkbox-' + message.id"
                aria-label="Check off"
                type="checkbox"
                :checked="message.checked"
                @change="checkOffMessage(message.id, index, $event.target.checked)"
              />
              <div
                :id="message.id"
                class="message"
                :class="message.checked && 'checked'"
              >
                <div x-text="message.text"></div>
                <span
                  x-text="renderMessageInfoText(message)"
                  class="message-info"
                ></span>
              </div>
            </div>
          </template>
        </div>
      </template>
      <template x-if="open === 0">
        <div
          class="message-input"
          x-data="{
          input: '',
          post() {
            postMessage(this.input.trim());
            $refs.input.innerText = '';
            $refs.input.focus();
          }
        }"
        >
          <div
            class="input-div"
            contenteditable="true"
            @input="input = $el.innerText"
            @paste="pasteAsPlainText($event)"
            x-ref="input"
          ></div>
          <div
            class="button"
            tabindex="0"
            @click="post()"
            @keyup.enter="post()"
          >
            &gt;
          </div>
        </div>
      </template>
      <!-- ------ NOTE PAGE ------ -->
      <template x-if="open !== 0">
        <div
          class="filler-container note-container"
          x-data="{
          note: '',
          post() {
            putNote(this.note);
          }
        }"
        >
          <div
            class="note"
            contenteditable="true"
            @input.debounce.800ms="note = $el.innerText"
          ></div>
        </div>
      </template>
    </div>
  </body>
</html>
