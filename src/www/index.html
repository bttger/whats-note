<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Note Messenger</title>
    <meta
      name="description"
      content="Send yourself messages, organize your notes, and sync them with all your devices"
    />
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" type="image/png" href="/images/NotoV1Memo_64x64.png" />
    <link rel="stylesheet" href="/css/style.css" />
    <script
      defer
      src="https://cdn.jsdelivr.net/npm/idb@7/build/umd.js"
    ></script>
    <script
      defer
      src="https://unpkg.com/alpinejs@3.10.3/dist/cdn.min.js"
    ></script>
    <script>
      const MAX_MESSAGES_TO_SYNC = 20;
      const SYNC_EVERY_SECS = 10;

      /*
      --- IndexedDB Functions ---
      */

      async function getDB() {
        return await idb.openDB("note-messenger", 1, {
          upgrade(db) {
            const messagesStore = db.createObjectStore("messages", {
              keyPath: "id",
            });
            messagesStore.createIndex("sentAt", "sentAt");
            messagesStore.createIndex("unsynced", "unsynced");
            const notesStore = db.createObjectStore("notes", {
              keyPath: "id",
            });
            notesStore.createIndex("unsynced", "unsynced");
          },
        });
      }

      async function selectMessages(db, count = 200, onlyId = false) {
        const messages = [];
        let cursor = await db
          .transaction("messages", "readonly")
          .store.index("sentAt")
          .openCursor(undefined, "prev");

        while (cursor && count > 0) {
          messages.unshift(onlyId ? cursor.value.id : cursor.value);
          cursor = await cursor.continue();
          count--;
        }

        return messages;
      }

      async function selectUnsyncedMessages(db) {
        return await db.getAllFromIndex("messages", "unsynced");
      }

      async function insertOrReplaceMessage(db, message) {
        await db.put("messages", message);
      }

      async function selectNote(db, id) {
        return (
          (await db.get("notes", id)) || {
            id,
            text: "",
            lastEdit: Date.now(),
            unsynced: 0,
            isSyncing: 0,
            lastSync: Date.now(),
          }
        );
      }

      async function selectNotes(db) {
        return await db.getAll("notes");
      }

      async function startUpdateNote(db, id, text) {
        const note = await selectNote(db, id);
        note.text = text;
        note.lastEdit = Date.now();
        note.isSyncing = 1;
        note.unsynced = 1;
        await db.put("notes", note);
        return note;
      }

      async function finishUpdateNote(db, id, error = false) {
        const note = await selectNote(db, id);
        note.isSyncing = 0;
        note.unsynced = error ? 1 : 0;
        note.lastSync = error ? note.lastSync : Date.now();
        await db.put("notes", note);
        return note;
      }

      async function syncNote(db, note) {
        note.isSyncing = 0;
        note.unsynced = 0;
        note.lastSync = Date.now();
        await db.put("notes", note);
      }

      /*
      --- API Fetch Functions ---
      */

      /**
       * Sends a GET request to the /sync endpoint
       * @param notes { string: number } The noteId as key and lastSync as value
       * @param messageIds [ string ] The last MAX_MESSAGES_TO_SYNC messageIds ordered by sentAt ASC
       * @returns Promise<{ notes: { string: noteObj }, messages: [ messageObj ]}>
       */
      async function getSyncRequest(notes, messageIds) {
        const notesLastSync = decodeURIComponent(JSON.stringify(notes));
        const messagesHash = cyrb53(JSON.stringify(messageIds));

        const response = await fetch(
          `/api/sync?notes=${notesLastSync}&messages=${messagesHash}`,
          { method: "GET" }
        );
        if (!response.ok) {
          if (response.status === 401) {
            window.location.replace("/login");
          } else {
            throw new Error(`Status code: ${response.status}`);
          }
        }
        return await response.json();
      }

      async function postMessagesRequest(messages) {
        if (!messages.length) return;

        // Ensure only necessary props are transmitted
        const messagesToSend = [];
        messages.forEach((m) => {
          messagesToSend.push({
            id: m.id,
            text: m.text,
            sentAt: m.sentAt,
            checked: m.checked,
          });
        });

        const response = await fetch("/api/messages", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify(messagesToSend),
        });
        if (!response.ok) {
          if (response.status === 401) {
            window.location.replace("/login");
          } else {
            throw new Error(`Status code: ${response.status}`);
          }
        }
      }

      async function patchMessageRequest(id, checked) {
        const response = await fetch(`/api/messages/${id}`, {
          method: "PATCH",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({ checked }),
        });
        if (!response.ok) {
          if (response.status === 401) {
            window.location.replace("/login");
          } else {
            throw new Error(`Status code: ${response.status}`);
          }
        }
      }

      async function putNoteRequest(note) {
        delete note.isSyncing;
        delete note.unsynced;
        delete note.lastSync;
        const response = await fetch(`/api/notes/${note.id}`, {
          method: "PUT",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify(note),
        });
        if (!response.ok) {
          if (response.status === 401) {
            window.location.replace("/login");
          } else {
            throw new Error(`Status code: ${response.status}`);
          }
        }
      }

      /*
      --- Utility Functions ---
      */

      function pasteAsPlainText(event) {
        event.preventDefault();
        document.execCommand(
          "insertHTML",
          false,
          event.clipboardData.getData("text/plain")
        );
      }

      function getInnerText(innerHTML) {
        // We need to remove double line breaks because Chrome inserts <div>'s
        // with <br>'s when breaking lines.
        // Usually, this could be done easily with ...
        // event.preventDefault();
        // document.execCommand("insertLineBreak");
        // ... but then, unfortunately, the browser wouldn't scroll the div
        // anymore when the user inserts line breaks.
        innerHTML = innerHTML.replace(/(^[^<]+)/, "$1\n");
        innerHTML = innerHTML.replaceAll("<br>", "\n");
        innerHTML = innerHTML.replaceAll(/<div>\\n<\/div>/g, "\n");
        innerHTML = innerHTML.replaceAll(/<div>([\s\S]*?)<\/div>/g, "$1\n");
        innerHTML = innerHTML.replaceAll("&nbsp;", " ");
        return innerHTML;
      }

      /*
          cyrb53 (c) 2018 bryc (github.com/bryc)
          A fast and simple hash function with decent collision resistance.
          Largely inspired by MurmurHash2/3, but with a focus on speed/simplicity.
          Public domain. Attribution appreciated.
      */
      const cyrb53 = function (str, seed = 0) {
        let h1 = 0xdeadbeef ^ seed,
          h2 = 0x41c6ce57 ^ seed;
        for (let i = 0, ch; i < str.length; i++) {
          ch = str.charCodeAt(i);
          h1 = Math.imul(h1 ^ ch, 2654435761);
          h2 = Math.imul(h2 ^ ch, 1597334677);
        }
        h1 =
          Math.imul(h1 ^ (h1 >>> 16), 2246822507) ^
          Math.imul(h2 ^ (h2 >>> 13), 3266489909);
        h2 =
          Math.imul(h2 ^ (h2 >>> 16), 2246822507) ^
          Math.imul(h1 ^ (h1 >>> 13), 3266489909);
        return 4294967296 * (2097151 & h2) + (h1 >>> 0);
      };

      /*
      --- Alpine Data ---
      */

      function data() {
        return {
          async init() {
            this.db = await getDB();
            await this._resetIsUploadingPropOnStartup();
            await this.openTab(0);
            setInterval(() => {
              this._syncWithServer();
            }, SYNC_EVERY_SECS * 1000);
          },
          db: null,
          // 0: Synced, 1: Syncing, 2: Unsynced due to network error
          state: 1,
          open: 0,
          tabs: [0, 1, 2, 3, 4, 5],
          displayedMessages: [],
          note: {
            id: 1,
            text: "",
            lastEdit: Date.now(),
            unsynced: 0,
            isSyncing: 0,
            lastSync: Date.now(),
          },
          async openTab(id) {
            this.open = id;
            this.state = 1;
            if (this.open === 0) {
              await this._updateDisplayedMessages();
              await this._syncWithServer();
            } else {
              await this._updateDisplayedNote();
              await this._syncWithServer();
            }
            if (this.state === 1) {
              this.state = 0;
            }
          },
          async _resetIsUploadingPropOnStartup() {
            const messages = await selectUnsyncedMessages(this.db);
            for (const m of messages) {
              m.isUploading = 0;
              await insertOrReplaceMessage(this.db, m);
            }
          },
          async _updateDisplayedMessages() {
            this.displayedMessages = await selectMessages(this.db);
            this.$nextTick(() =>
              document.getElementById("message-container-end").scrollIntoView()
            );
          },
          async _syncWithServer() {
            // Post unsynced messages if there are any
            const messagesPossiblyToSync = await selectUnsyncedMessages(
              this.db
            );
            const messagesToSync = messagesPossiblyToSync.filter(
              (m) => !m.isUploading
            );
            for (const m of messagesToSync) {
              m.isUploading = 1;
              await insertOrReplaceMessage(this.db, m);
            }
            try {
              await postMessagesRequest(messagesToSync);
              for (const m of messagesToSync) {
                delete m.isUploading;
                delete m.unsynced;
                await insertOrReplaceMessage(this.db, m);
              }
            } catch (error) {
              console.log(error);
              for (const m of messagesToSync) {
                m.isUploading = 0;
                await insertOrReplaceMessage(this.db, m);
              }
            }
            // Fetch new messages and updated notes from server
            try {
              const notesLastSync = {};
              for (const note of await selectNotes(this.db)) {
                notesLastSync[note.id] = note.lastSync;
              }

              const resp = await getSyncRequest(
                notesLastSync,
                await selectMessages(this.db, MAX_MESSAGES_TO_SYNC, true)
              );
              if (resp.messages) {
                for (const m of resp.messages) {
                  await insertOrReplaceMessage(this.db, m);
                }
                if (this.open === 0) {
                  await this._updateDisplayedMessages();
                }
              }
              if (resp.notes) {
                for (const [noteId, note] of Object.entries(resp.notes)) {
                  await syncNote(this.db, note);
                  if (this.open.toString() === noteId) {
                    await this._updateDisplayedNote();
                  }
                }
              }
            } catch (error) {
              console.log(error);
              // TODO unsynced state
              // if it fails, the client is in stale state and could possibly overwrite data written by another client when reconnecting
            }
          },
          async postMessage(innerHtml) {
            const text = getInnerText(innerHtml).trim();

            if (!text) return;

            const message = {
              id: crypto.randomUUID(),
              text,
              sentAt: Date.now(),
              checked: false,
              unsynced: 1,
              isUploading: 1,
            };

            await insertOrReplaceMessage(this.db, message);
            await this._updateDisplayedMessages();

            try {
              await postMessagesRequest([message]);
              delete message.isUploading;
              delete message.unsynced;
              await insertOrReplaceMessage(this.db, message);
            } catch (error) {
              message.isUploading = 0;
              await insertOrReplaceMessage(this.db, message);
              console.log(error);
            }

            await this._updateDisplayedMessages();
          },
          async checkOffMessage(id, checked = true) {
            try {
              await patchMessageRequest(id, checked);
            } catch (error) {
              document.getElementById(`checkbox-${id}`).checked = !checked;
            }
          },
          async _updateDisplayedNote() {
            this.note = await selectNote(this.db, this.open);
            this.$refs.note.innerHTML = this.note.text;
          },
          async editNote(innerHtml) {
            let note;
            try {
              note = await startUpdateNote(
                this.db,
                this.note.id,
                getInnerText(innerHtml)
              );
              await putNoteRequest(note);
              this.note = await finishUpdateNote(this.db, note.id);
            } catch (error) {
              this.note = await finishUpdateNote(this.db, note.id, true);
            }
          },
        };
      }
    </script>
  </head>
  <body x-data="data()">
    <div class="container">
      <!-- ------ STATE BAR ------ -->
      <div
        x-show="state !== 0"
        class="state-bar"
        :style="state === 1 ? 'background: #000bda' : 'background: #d80000'"
      ></div>
      <!-- ------ TAB NAVIGATION ------ -->
      <div class="tabs">
        <template x-for="tab in tabs">
          <div
            x-text="tab"
            class="button tab"
            :class="tab === open && 'focused'"
            @click="openTab(tab)"
          ></div>
        </template>
      </div>
      <!-- ------ MESSENGER ------ -->
      <template x-if="open === 0">
        <div class="filler-container">
          <template x-for="message in displayedMessages" :key="message.id">
            <div class="message-container">
              <input
                :id="'checkbox-' + message.id"
                aria-label="Check off"
                type="checkbox"
                :checked="message.checked"
                @change="checkOffMessage(message, $event.target.checked)"
              />
              <div class="message" :class="message.checked && 'checked'">
                <div x-text="message.text"></div>
                <span
                  x-text="new Date(message.sentAt).toLocaleString() + (message.unsynced ? ' ▴' : ' ✓')"
                  class="message-info"
                ></span>
              </div>
            </div>
          </template>
          <div
            id="message-container-end"
            style="height: 1px; margin-top: -1px"
          ></div>
        </div>
      </template>
      <template x-if="open === 0">
        <div
          class="message-input"
          x-data="{
          post() {
            postMessage($refs.input.innerHTML);
            $refs.input.innerHTML = '';
            $refs.input.focus();
          }
        }"
        >
          <div
            x-ref="input"
            class="input-div"
            contenteditable="true"
            @paste="pasteAsPlainText($event)"
          ></div>
          <div
            class="button"
            tabindex="0"
            @click="post()"
            @keyup.enter="post()"
          >
            &gt;
          </div>
        </div>
      </template>
      <!-- ------ NOTE PAGE ------ -->
      <template x-if="open !== 0">
        <div class="filler-container">
          <div
            x-ref="note"
            class="note"
            contenteditable="true"
            @input.debounce.600ms="editNote($el.innerHTML)"
            @paste="pasteAsPlainText($event)"
          ></div>
        </div>
      </template>
      <template x-if="open !== 0">
        <div class="note-info-container">
          <div>
            <div class="button" style="margin-right: 0.3rem">↶</div>
            <div class="button">↷</div>
          </div>
          <div class="note-info">
            <div
              x-text="'Last edit: ' + new Date(note.lastEdit).toLocaleString()"
            ></div>
          </div>
        </div>
      </template>
    </div>
  </body>
</html>
